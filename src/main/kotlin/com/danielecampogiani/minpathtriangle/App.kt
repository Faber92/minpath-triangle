/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.danielecampogiani.minpathtriangle

import java.io.File

sealed class Node<T>(
    open val value: T
)

data class Parent<T>(
    override val value: T,
    val left: Node<T>,
    val right: Node<T>
) : Node<T>(value)

data class Child<T>(
    override val value: T
) : Node<T>(value)


fun main() {

    val filename = "data.txt"
    println("Reading $filename")
    val lines = readLines(filename)
    println("Data from file is:")
    lines.forEach {
        println(it)
    }
    val modelData = modelData(lines)
    val min = findMin(modelData)
    val max = findMax(modelData)
    println("Min: $min")
    println("Max: $max")
}

fun readLines(fileName: String): List<List<Int>> = File(fileName)
    .readLines()
    .map { line ->
        line.split(" ").map { char -> char.toInt() }
    }

fun modelData(input: List<List<Int>>): Node<Int> = extractNode(input, 0, 0)

private fun extractNode(input: List<List<Int>>, lineIndex: Int, rowIndex: Int): Node<Int> {
    val value = input[lineIndex][rowIndex]
    return if (lineIndex == input.size - 1) {
        Child(value)
    } else {
        val left = extractNode(input, lineIndex + 1, rowIndex)
        val right = extractNode(input, lineIndex + 1, rowIndex + 1)
        Parent(value, left, right)
    }
}

fun findMax(input: Node<Int>): Int {
    return find(input,
        aggregate = { a, b -> a + b },
        choose = { a, b -> maxOf(a, b) })
}

fun findMin(input: Node<Int>): Int {
    return find(input,
        aggregate = { a, b -> a + b },
        choose = { a, b -> minOf(a, b) })
}

private fun <T> find(input: Node<T>, aggregate: (T, T) -> T, choose: (T, T) -> T): T {
    return when (input) {
        is Parent -> {
            aggregate(
                input.value, choose(
                    find(input.left, aggregate, choose),
                    find(input.right, aggregate, choose)
                )
            )
        }
        is Child -> input.value
    }
}

